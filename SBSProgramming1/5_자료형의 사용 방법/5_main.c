#include <stdio.h>
#include <stdint.h>

int main()
{
	printf("5강 시작!\n");

	// 정수, 실수 구분해야 한다.
	// 메모리의 크기를 지정할 수 있다.
	// sizeof
	// 정수 형태의 자료형들 char, short, int ,long ,long long
	// 1바이트의 크기를 저장할 수 있고 데이터를 읽는 방식은 정수다 + 이름은 number1;
	// 
	char number1;    // number1 char자료형태로 데이터를 저장할 수 있게 (변수 선언).
	short number2;
	int number3;
	long number4;
	long long number5;

	printf("char자료형의 크기 : %llu\n", sizeof(char));	// 바이트의 크기
	printf("short자료형의 크기 : %llu\n", sizeof(short));
	printf("int자료형의 크기 : %llu\n", sizeof(int));
	printf("long자료형의 크기 : %llu\n", sizeof(long));
	printf("long long자료형의 크기 : %llu\n", sizeof(long long));

	// int, long 같은 크기의 자료형을 선언했을까?
	// 자료형 최소 ~ 최대 크기가 지정이 되어있다.
	// 컴파일러 자료형의 크기가 다르다.

	int16_t num1 = 1; 	// 8 x 2 = 2바이트
	int32_t num2 = 1;	// 8 x 4
	int64_t num3 = 1;	// 8 x 8 
	printf("int16_t자료형의 크기 : %llu\n", sizeof(int16_t));
	printf("int32_t자료형의 크기 : %llu\n", sizeof(int32_t));
	printf("int64_t자료형의 크기 : %llu\n", sizeof(int64_t));

	// 오버플로우
	// 부호가 있는 정수, 부호가 없는 정수 => MSB 0, 1 (0 양수, 1 음수)
	// unsigned << 양수만 표현하겠다. 2^7 -> 2^8   128양의 정수 더 표현할 수 있다.
	// 레벨 데이터 표현. 정수형태의 자료형 선택하고 싶다.  char, short, int ,long , long long

	// 레벨 데이터 저장해둘건데, 어떤 데이터 타입으로 설정하는게 가장 효과적일까?
	// int -> 21억, 충분한 공간을 확보할 수 있다.
	// 최대 레벨 존재. 999,999 -> 적은 크기의 데이터를 저장하는데 불필요한 공간을 사용할 수 있다.
	// 확장이 될 수 있다. 21억 큰 숫자를 표현하게 될 수 있지 않을까/
	// 데미지. 9999억, 21억      2^4x8 
	// 2^64 -> 숫자 단위에 맞게끔 표현해야 하는가? 조 ->  1$

	char level = 1;	  // 0000 0001
	printf("현재 레벨 : %d\n", level);
	level = 1 + 128;  // 0111 1111  127 // 1000 0000 0000 0000
	printf("현재 레벨 : %d\n", level);
	unsigned char level2 = 1; // 0 ~ 최대 값. 42억.

	// 음수를 표현하는 방법 고찰.

	// 1110001(2) 이진수 
	// 12345678   십진수 -> 8x1 +7 x 10 + 6 x 10^2 + ...
	// 00000101 => 2^0 x1 + 2^2x1 = 5

	// 부호를 표현하는 숫자만 0,1 2진법 나머지를 표현해보자.
	// -5 비트로 표현을 하고 싶다.   1000101 => 4+ 1 =5 ->
	// 5 + (-5) = 0
	// 1000101 [-5] 
	// 0000101 [5]
	// 1001010 [-10] 5-5 = -10
	// 두 수를 더하면 0이되어야한다. 
	// 0000101
	// 1111010
	// 1111111 +1
	//1 0000 0000
	// 비트를 모두 반대로 변환하고 1을 더해준다. => 2의 보수법

	// 2바이트 Short [0000 0000][0000 0001]   1
	//              [1111 1111] [1111 1111]  -1

	// 소수점이 없는 숫자를 표현하였습니다.
	// float, double, long double

	float n1 = 0.00123f;   // 4바이트  
	double n2 = 0.00123;   // 8바이트
	long double n3 = 0.00123;
	printf("float의 크기 : %llu\n", sizeof(float));
	printf("double의 크기 : %llu\n", sizeof(double));
	printf("long double의 크기 : %llu\n", sizeof(long double));

	// 4x8 비트 공간에서 실수를 표현하기 위한 방법?
	// (정수)소수점(실수)
	// [     정수   ][    소수점     ]     [0][ 7      ] [    ] =>  24.4 => 표현할 수 잇는 가지수가 너무 적다.
	// 1.000000000000000000125 
	// 고정 소수점  
	// float 부동소수점, 둥둥 떠다니다

	// 1.3  13000   => 1.3 x 10^4   => 2진수로 표현하는 로직 => IEEE754    
	// -13000	    => [1][ 몇 승 증가했는가?][유효 숫자는 얼마인가]
	// 0.0123	    = 1.23 x 10^-2
	// -0.0123		= -1.23 x 10^-2

	// 컴퓨터는 10진수 표기법을 사용하지 않고 2진수 표기법 사용을 한다.
	// 고정 소수점 : 정확한 소수를 표현할 수 있다, 소수를 표현하기에는 공간이 너무 부족하다.
	// 부동 소수점 : 2^?   +  유효숫자 표기,  소수점이 정확하지 않다.
	// 컴퓨터에서 실수를 표현하는 방식은 정확하게 일치하지 않다.

	// 특정 조건이 만족하면 어떤 코드를 실행해라.
	float n4 = 0.3f; // 0.300000011920928955078125
	float n5 = 0.4f; // 0.4000000059604644775390625
	float n6 = 0.7f; // 0.699999988079071044921875
	// 0.7000000178813934326171875
	// 실험실 결과 추론 코드로 결과를 유추할 수 있습니다.
	// 물리현상을 추론하기 위해서 넣어서 시뮬레이션.
	// 특정 자리수 까지만 사용하겠다
	// 자리수가 어디까지 정확한지를 표현을 하고 있습니다.
	// float, double -> 소수점을 표현하는 정확성이 다르다.
	// 소수점이 명확하게 표현이 되고 있지 않다.
	// 소수점의 계산을 통해서 특정 결과값을 유추하는 코드는 문제가 있을 수 있다.
	if (n6 == n4 + n5)
	{
		printf("0.7 = 0.3 + 0.4 같습니다\n");
	}
	else
	{
		printf("0.7 = 0.3 + 0.4 다릅니다\n");
	}
	// comment 

	// 문자를 표현하는 방법

	char character1 = 97;    // 8개               01100001
	short character2 = 97;	 // 16개   00000000   01100001
	int character3 = 97;	 // 32개 [ ] [ ] [ ]  01100001
	double character4 = 97;	 // %c 안될까요?

	// 똑같은 데이터를 사용하는데 어떻게 사용하느냐에 따라서 결과가 달라진다.

	printf("%c\n", character1);
	printf("%c\n", character2);	  // 문자를 표현	-> 낭비되는 메모리가 있더라
	printf("%c\n", character3);	  // 문자를 표현 -> 낭비되는 메모리가 있더라
	//printf("%c\n", character4); // character4 97값이 안들어 있기 때문에 문자를 제대로 표현하지 못했다.

	// char 문자를 표현하는 타입이다.
	// 그래서 한글은요?
	// 자음 + 모음 ,   자음 + 모음 + 자음/  모음x 
	// 조합형 쓸까?
	// 완성형 쓸까?  가 -> 1  char -> 128 -> 한글을 표현하기에는 너무 부족합니다.
	// ((히라가나,가타가나,한자), 중국) 
	// EUC_KR 2350 한글로 표현 ? -> 펲시콜라 -> CP949(2바이트) 모든 한글을 표현할 수 있도록 대응되도록 만들었습니다. 
	// ANSI
	// UTF-8(3바이트) 유니코드, 통일성, 
	// [EUC_KR] 인코딩 되어 코드를 UTF-8 바꾸는 API    걃기안대갼므퍄뒤쟈구
	// 한글을 표현하는 방식에 대해서 조사.   인코딩 000101010(2) 한글 디코딩

	// 코드의 흐름 ( 반복문, 조건문)
}